<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grocery List</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#4A7C20">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #FAF8F3;
            min-height: 100vh;
            padding: 0;
        }
        
        .sticky-top {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #FAF8F3;
            background: rgba(250, 248, 243, 0.5);
            backdrop-filter: blur(12px);
           
        }
        
        .header {
            text-align: center;
            color: #2D5016;
            padding: 20px 20px 16px;
        }
        
        .header h1 {
            font-family: Georgia, 'Times New Roman', serif;
            font-size: 36px;
            font-weight: 400;
            letter-spacing: -0.5px;
            margin-bottom: 8px;
        }
        
        .header p {
            color: #4A7C20;
            font-size: 14px;
        }
        
        .list-container {
            padding: 16px 20px 40px;
            max-width: 440px;
            margin: 0 auto;
        }
        
        .add-item-wrapper {
            padding: 0 20px 20px;
            max-width: 440px;
            margin: 0 auto;
        }
        
        .add-item-field {
            background: white;
            border: 2px dashed #D4CDBD;
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .add-item-field:focus-within {
            border-color: #4A7C20;
            border-style: solid;
            box-shadow: 0 4px 12px rgba(74, 124, 32, 0.1);
        }
        
        .add-item-field input {
            flex: 1;
            border: none;
            font-size: 16px;
            background: transparent;
            outline: none;
            color: #2D5016;
        }
        
        .add-item-field input::placeholder {
            color: #A8A292;
        }
        
        .item {
            background: white;
            border: 1px solid #E8E3D3;
            border-radius: 12px;
            padding: 8px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            animation: slideIn 0.3s ease;
            position: relative;
            overflow: hidden;
            touch-action: none;
            cursor: grab;
        }
        
        .item.dragging {
            opacity: 0.5;
            cursor: grabbing;
            z-index: 1000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        }
        
        .item.drag-over {
            transform: translateY(4px);
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .item.swiping {
            transition: none;
        }
        
        .item.done {
            opacity: 0.7;
            background: #FDFCF8;
        }
        
        .item.done .item-text {
            text-decoration: line-through;
            color: #A8A292;
        }
        
        .item-content {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
            position: relative;
            background: inherit;
            z-index: 2;
        }
        
        .delete-background {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            background: #D4674A;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 20px;
            color: white;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .item.show-delete .delete-background {
            opacity: 1;
        }
        
        .checkbox {
            width: 24px;
            height: 24px;
            border: 2px solid #D4CDBD;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            flex-shrink: 0;
        }
        
        .item.done .checkbox {
            background: #4A7C20;
            border-color: #4A7C20;
        }
        
        .item.done .checkbox::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
        }
        
        .item-text {
            flex: 1;
            font-size: 16px;
            color: #2D5016;
            word-break: break-word;
            user-select: none;
        }
        
        .delete-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            color: #D4CDBD;
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .delete-btn:hover {
            color: #D4674A;
        }
        
        .delete-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .empty-state {
            text-align: center;
            color: #6B8E59;
            padding: 40px;
            font-size: 18px;
            font-family: Georgia, 'Times New Roman', serif;
        }
        
        .offline-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #D4674A;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            display: none;
            animation: pulse 2s infinite;
            z-index: 200;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        @media (max-width: 400px) {
            .header h1 {
                font-size: 32px;
            }
            
            .list-container {
                padding: 0 16px 40px;
            }
        }
    </style>
</head>
<body>
    <div class="sticky-top">
        <div class="header">
            <h1>Grocery List</h1>
        </div>
        
        <div class="add-item-wrapper">
            <div class="add-item-field">
                <input type="text" id="newItem" placeholder="Add item..." autocomplete="off" enterkeyhint="done">
            </div>
        </div>
    </div>
    
    <div class="offline-indicator" id="offlineIndicator">Offline</div>
    
    <div class="list-container">
        <div id="list">
            <div class="empty-state">Your grocery list is empty</div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <!-- Firebase Config -->
    <script src="firebase-config.js"></script>
    
    <script>
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // Enable offline persistence
        db.enablePersistence()
            .catch((err) => {
                if (err.code == 'failed-precondition') {
                    console.log('Multiple tabs open, persistence can only be enabled in one tab at a time.');
                } else if (err.code == 'unimplemented') {
                    console.log('The current browser does not support offline persistence');
                }
            });
        
        // References
        const itemsRef = db.collection('groceries');
        const listEl = document.getElementById('list');
        const newItemInput = document.getElementById('newItem');
        const offlineIndicator = document.getElementById('offlineIndicator');
        
        // Track items
        let items = new Map();
        let itemOrder = [];
        
        // Drag and drop variables
        let draggedElement = null;
        let draggedItem = null;
        let placeholder = null;
        let touchStartY = 0;
        let touchCurrentY = 0;
        
        // Listen for real-time updates
        itemsRef.orderBy('order', 'asc').orderBy('createdAt', 'desc').onSnapshot((snapshot) => {
            snapshot.docChanges().forEach((change) => {
                const doc = change.doc;
                const data = { id: doc.id, ...doc.data() };
                
                if (change.type === 'added') {
                    items.set(doc.id, data);
                    if (!document.getElementById(doc.id)) {
                        addItemToDOM(data);
                    }
                } else if (change.type === 'modified') {
                    items.set(doc.id, data);
                    updateItemInDOM(data);
                } else if (change.type === 'removed') {
                    items.delete(doc.id);
                    removeItemFromDOM(doc.id);
                }
            });
            
            updateItemOrder();
            updateEmptyState();
        }, (error) => {
            console.error('Error listening to changes:', error);
        });
        
        // Update item order array
        function updateItemOrder() {
            itemOrder = Array.from(items.values())
                .sort((a, b) => {
                    if (a.order !== undefined && b.order !== undefined) {
                        return a.order - b.order;
                    }
                    return (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0);
                });
            
            // Reorder DOM elements
            const itemElements = Array.from(listEl.querySelectorAll('.item'));
            itemOrder.forEach((item, index) => {
                const element = document.getElementById(item.id);
                if (element && itemElements[index] && element !== itemElements[index]) {
                    listEl.insertBefore(element, itemElements[index]);
                }
            });
        }
        
        // Add item
        function addItem() {
            const text = newItemInput.value.trim();
            if (!text) return;
            
            const maxOrder = Math.max(...Array.from(items.values()).map(item => item.order || 0), -1);
            
            itemsRef.add({
                text: text,
                done: false,
                order: maxOrder + 1,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            }).then(() => {
                newItemInput.value = '';
                // Keep focus on input for rapid entry
                newItemInput.focus();
            }).catch((error) => {
                console.error('Error adding item:', error);
                alert('Failed to add item. Please try again.');
            });
        }
        
        // Toggle item done status
        function toggleItem(id) {
            const item = items.get(id);
            if (item) {
                itemsRef.doc(id).update({
                    done: !item.done
                }).catch((error) => {
                    console.error('Error toggling item:', error);
                });
            }
        }
        
        // Delete item
        function deleteItem(id) {
            itemsRef.doc(id).delete().catch((error) => {
                console.error('Error deleting item:', error);
                alert('Failed to delete item. Please try again.');
            });
        }
        
        // Reorder items
        async function reorderItems(draggedId, targetId, insertBefore) {
            try {
                const currentOrder = itemOrder.map(item => item.id);
                const draggedIndex = currentOrder.indexOf(draggedId);
                const targetIndex = currentOrder.indexOf(targetId);
                
                if (draggedIndex === -1 || targetIndex === -1) return;
                
                // Remove dragged item from array
                currentOrder.splice(draggedIndex, 1);
                
                // Insert at new position
                const newIndex = insertBefore ? targetIndex : targetIndex + 1;
                currentOrder.splice(newIndex, 0, draggedId);
                
                // Update order values in batch
                const batch = db.batch();
                currentOrder.forEach((id, index) => {
                    batch.update(itemsRef.doc(id), { order: index });
                });
                
                await batch.commit();
            } catch (error) {
                console.error('Error reordering items:', error);
            }
        }
        
        // DOM manipulation functions
        function addItemToDOM(item) {
            const itemEl = document.createElement('div');
            itemEl.className = `item ${item.done ? 'done' : ''}`;
            itemEl.id = item.id;
            itemEl.draggable = true;
            itemEl.innerHTML = `
                <div class="item-content">
                    <div class="checkbox" onclick="toggleItem('${item.id}')"></div>
                    <div class="item-text">${escapeHtml(item.text)}</div>
                    <button class="delete-btn" onclick="deleteItem('${item.id}')" title="Delete">
                        <svg viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
                            <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                <g transform="translate(-27.5, -1)" fill="currentColor" fill-rule="nonzero">
                                    <path d="M147.112511,343.727844 C150.963219,343.727844 154.055871,342.602661 156.390465,340.352295 C158.72506,338.101929 159.822777,335.179565 159.683617,331.585205 L154.058617,140.390137 C154.016503,136.700562 152.817162,133.789185 150.460595,131.656006 C148.104027,129.522827 145.080956,128.456238 141.391381,128.456238 C137.489403,128.456238 134.399956,129.552124 132.12304,131.743896 C129.846123,133.935669 128.777245,136.876343 128.916405,140.565918 L134.222802,331.651123 C134.457177,335.340698 135.723351,338.275879 138.021325,340.456665 C140.319298,342.637451 143.349694,343.727844 147.112511,343.727844 Z M201.01693,343.727844 C204.874962,343.727844 207.995537,342.642487 210.378655,340.471771 C212.761773,338.301056 213.953331,335.370911 213.953331,331.681335 L213.953331,140.5 C213.953331,136.810425 212.761773,133.880737 210.378655,131.710938 C207.995537,129.541138 204.874962,128.456238 201.01693,128.456238 C197.230309,128.456238 194.145897,129.541138 191.763695,131.710938 C189.381493,133.880737 188.190392,136.810425 188.190392,140.5 L188.190392,331.681335 C188.190392,335.370911 189.381493,338.301056 191.763695,340.471771 C194.145897,342.642487 197.230309,343.727844 201.01693,343.727844 Z M255.031212,343.727844 C258.79403,343.727844 261.824425,342.661255 264.122399,340.528076 C266.420372,338.394897 267.638939,335.435913 267.7781,331.651123 L273.084496,140.565918 C273.221825,136.876343 272.152489,133.935669 269.876488,131.743896 C267.600487,129.552124 264.511498,128.456238 260.60952,128.456238 C257.01516,128.456238 254.039696,129.522827 251.683129,131.656006 C249.326561,133.789185 248.078698,136.748169 247.939538,140.532959 L242.460106,331.585205 C242.342919,335.27478 243.427819,338.220947 245.714806,340.423706 C248.001793,342.626465 251.107262,343.727844 255.031212,343.727844 Z M121.107872,82.390564 L121.107872,44.270752 C121.107872,30.8839111 125.197991,20.4102783 133.378228,12.8498535 C141.558465,5.28942871 152.913292,1.50921631 167.442711,1.50921631 L234.269799,1.50921631 C248.799218,1.50921631 260.154046,5.28942871 268.334282,12.8498535 C276.514519,20.4102783 280.604638,30.8839111 280.604638,44.270752 L280.604638,82.390564 L248.079613,82.390564 L248.079613,45.8994751 C248.079613,41.4298706 246.612938,37.8272705 243.679589,35.0916748 C240.746239,32.3560791 236.836937,30.9882812 231.951684,30.9882812 L169.763573,30.9882812 C164.876488,30.9882812 160.966729,32.3560791 158.034295,35.0916748 C155.101861,37.8272705 153.635643,41.4298706 153.635643,45.8994751 L153.635643,82.390564 L121.107872,82.390564 Z M43.2697377,101.608398 C39.0015492,101.608398 35.3344045,100.101898 32.2683034,97.0888977 C29.2022023,94.0758972 27.6691518,90.3876953 27.6691518,86.024292 C27.6691518,81.7780762 29.2022023,78.1539612 32.2683034,75.151947 C35.3344045,72.1499329 39.0015492,70.6489258 43.2697377,70.6489258 L358.873986,70.6489258 C363.142174,70.6489258 366.785515,72.1261292 369.804009,75.0805359 C372.822503,78.0349426 374.331749,81.6828613 374.331749,86.024292 C374.331749,90.3876953 372.846306,94.0758972 369.87542,97.0888977 C366.904534,100.101898 363.237389,101.608398 358.873986,101.608398 L43.2697377,101.608398 Z M120.283898,398.26123 C106.74508,398.26123 95.8965383,394.432953 87.7382741,386.776398 C79.5800099,379.119843 75.1978383,368.512085 74.5917592,354.953125 L62.3694692,97.9499512 L339.631432,97.9499512 L327.551964,354.810303 C326.944054,368.369263 322.537163,379.000824 314.331292,386.704987 C306.12542,394.409149 295.301598,398.26123 281.859826,398.26123 L120.283898,398.26123 Z"></path>
                                </g>
                            </g>
                        </svg>
                    </button>
                </div>
            `;
            
            // Add drag event listeners
            setupDragAndDrop(itemEl);
            
            // Insert based on order
            const correctPosition = itemOrder.findIndex(item => item.id === item.id);
            const allItems = listEl.querySelectorAll('.item');
            
            if (correctPosition >= 0 && correctPosition < allItems.length) {
                listEl.insertBefore(itemEl, allItems[correctPosition]);
            } else {
                listEl.appendChild(itemEl);
            }
        }
        
        function setupDragAndDrop(itemEl) {
            // Desktop drag events
            itemEl.addEventListener('dragstart', handleDragStart);
            itemEl.addEventListener('dragover', handleDragOver);
            itemEl.addEventListener('drop', handleDrop);
            itemEl.addEventListener('dragend', handleDragEnd);
            
            // Touch events
            itemEl.addEventListener('touchstart', handleTouchStart, { passive: false });
            itemEl.addEventListener('touchmove', handleTouchMove, { passive: false });
            itemEl.addEventListener('touchend', handleTouchEnd);
        }
        
        // Desktop drag handlers
        function handleDragStart(e) {
            draggedElement = this;
            draggedItem = items.get(this.id);
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }
        
        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            const afterElement = getDragAfterElement(listEl, e.clientY);
            if (afterElement == null) {
                listEl.appendChild(draggedElement);
            } else {
                listEl.insertBefore(draggedElement, afterElement);
            }
            
            return false;
        }
        
        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (draggedElement !== this) {
                const allItems = [...listEl.querySelectorAll('.item:not(.dragging)')];
                const draggedIndex = allItems.indexOf(draggedElement);
                const targetIndex = allItems.indexOf(this);
                
                if (draggedIndex !== -1 && targetIndex !== -1) {
                    const insertBefore = draggedIndex > targetIndex;
                    reorderItems(draggedElement.id, this.id, insertBefore);
                }
            }
            
            return false;
        }
        
        function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggedElement = null;
            draggedItem = null;
        }
        
        // Touch handlers
        function handleTouchStart(e) {
            const touch = e.touches[0];
            draggedElement = this;
            draggedItem = items.get(this.id);
            touchStartY = touch.clientY;
            
            // Create placeholder
            placeholder = this.cloneNode(true);
            placeholder.style.opacity = '0.5';
            placeholder.classList.add('placeholder');
            
            // Start dragging after a small delay
            setTimeout(() => {
                if (draggedElement) {
                    draggedElement.classList.add('dragging');
                    draggedElement.style.position = 'fixed';
                    draggedElement.style.zIndex = '1000';
                    draggedElement.style.width = draggedElement.offsetWidth + 'px';
                    
                    listEl.insertBefore(placeholder, draggedElement);
                }
            }, 100);
        }
        
        function handleTouchMove(e) {
            if (!draggedElement) return;
            
            e.preventDefault();
            const touch = e.touches[0];
            touchCurrentY = touch.clientY;
            
            // Move the dragged element
            draggedElement.style.top = (touch.clientY - 30) + 'px';
            draggedElement.style.left = '20px';
            draggedElement.style.right = '20px';
            
            // Find element under touch point
            const afterElement = getDragAfterElement(listEl, touch.clientY);
            if (placeholder && afterElement) {
                listEl.insertBefore(placeholder, afterElement);
            } else if (placeholder) {
                listEl.appendChild(placeholder);
            }
        }
        
        function handleTouchEnd(e) {
            if (!draggedElement) return;
            
            draggedElement.classList.remove('dragging');
            draggedElement.style.position = '';
            draggedElement.style.top = '';
            draggedElement.style.left = '';
            draggedElement.style.right = '';
            draggedElement.style.zIndex = '';
            draggedElement.style.width = '';
            
            if (placeholder) {
                // Find the item before the placeholder
                const prevItem = placeholder.previousElementSibling;
                const nextItem = placeholder.nextElementSibling;
                
                if (prevItem && prevItem.classList.contains('item') && prevItem !== draggedElement) {
                    reorderItems(draggedElement.id, prevItem.id, false);
                } else if (nextItem && nextItem.classList.contains('item') && nextItem !== draggedElement) {
                    reorderItems(draggedElement.id, nextItem.id, true);
                }
                
                placeholder.remove();
                placeholder = null;
            }
            
            draggedElement = null;
            draggedItem = null;
        }
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.item:not(.dragging):not(.placeholder)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        
        function updateItemInDOM(item) {
            const itemEl = document.getElementById(item.id);
            if (itemEl) {
                itemEl.className = `item ${item.done ? 'done' : ''}`;
            }
        }
        
        function removeItemFromDOM(id) {
            const itemEl = document.getElementById(id);
            if (itemEl) {
                itemEl.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => itemEl.remove(), 300);
            }
        }
        
        function updateEmptyState() {
            const hasItems = listEl.querySelector('.item');
            const emptyState = listEl.querySelector('.empty-state');
            
            if (!hasItems && !emptyState) {
                listEl.innerHTML = '<div class="empty-state">Your grocery list is empty</div>';
            } else if (hasItems && emptyState) {
                emptyState.remove();
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Handle enter key
        newItemInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addItem();
            }
        });
        
        // Auto-focus on load
        window.addEventListener('load', () => {
            newItemInput.focus();
        });
        
        // Online/offline detection
        window.addEventListener('online', () => {
            offlineIndicator.style.display = 'none';
        });
        
        window.addEventListener('offline', () => {
            offlineIndicator.style.display = 'block';
        });
        
        // PWA Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(reg => console.log('Service Worker registered'))
                    .catch(err => console.log('Service Worker registration failed'));
            });
        }
    </script>
</body>
</html>